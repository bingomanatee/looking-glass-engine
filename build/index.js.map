{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 3465eda619ccfe53b807","webpack:///external \"rxjs\"","webpack:///./src/constants.js","webpack:///./src/util.js","webpack:///./src/Store/Store.js","webpack:///./src/Store/index.js","webpack:///./src/ChangePromise/ChangePromise.js","webpack:///./src/ChangePromise/index.js","webpack:///./src/index.js","webpack:///./src/bottle.js","webpack:///external \"bottlejs\""],"names":["bottle","Symbol","out","error","first","result","err","fn","done","fail","promise","Object","change","delta","subject","Promise","call","state","killSwitch","from","errorMessage","delayTime","delay","race","isPromise","constructor","source","config","status","addActions","actions","actionsMap","mutator","message","mutators","addAction","action","update","setTimeout","console","_delay","sub","_resolve","newState","afterStart","afterStop","afterInitError","after","info","what","restart","start","stop","onError","_log","clone","_cloneError","storeFactory","nextId","resolve","unravelled","reject","then","catch","changePromiseFactory","Bottle","factory","container","Store","Engine","EngineMerger","mergeIntoState","STORE_STATE_UNSET_VALUE","S_NEW","S_STARTED","S_STARTING","S_ERROR","ACTION_ERROR","ACTION_START","ACTION_NOOP","ACTION_COMPLETE","NOT_SET"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"freactal3\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"freactal3\"] = factory();\n\telse\n\t\troot[\"freactal3\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 3465eda619ccfe53b807","module.exports = require(\"rxjs\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"rxjs\"\n// module id = 0\n// module chunks = 0","\n\nexport default (bottle) => {\n  bottle.constant('STORE_STATE_UNSET_VALUE', Symbol('STORE_STATE_UNSET_VALUE'));\n  bottle.constant('S_NEW', Symbol('S_NEW'));\n  bottle.constant('S_STARTED', Symbol('S_STARTED'));\n  bottle.constant('S_STOPPED', Symbol('S_STOPPED'));\n  bottle.constant('S_STARTING', Symbol('S_STARTING'));\n  bottle.constant('S_ERROR', Symbol('S_ERROR'));\n  bottle.constant('ACTION_ERROR', Symbol('ACTION_ERROR'));\n  bottle.constant('ACTION_START', Symbol('ACTION_START'));\n  bottle.constant('ACTION_WORKING', Symbol('ACTION_WORKING'));\n  bottle.constant('ACTION_NOOP', Symbol('ACTION_NOOP'));\n  bottle.constant('ACTION_COMPLETE', Symbol('ACTION_COMPLETE'));\n  bottle.constant('NOT_SET', Symbol('NOT_SET'));\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/constants.js","import { from, race } from 'rxjs';\nimport { delay } from 'rxjs/operators';\n\nexport default (bottle) => {\n  /**\n   * decomposes a promise into result and error;\n   * returns these in an array which also has properties of result and error,\n   * so\n   *\n   * const [result, error] = p(promiseFn())\n   *\n   * is valid as is\n   *\n   * const {result, error} = p(promiseFn());\n   *\n   * accepts a promise, or a function that is called with the remaining arguments.\n   */\n  bottle.factory('p', () => async (first, ...args) => {\n    let error = null;\n    let result;\n    try {\n      if (typeof first === 'function') {\n        result = await first(...args);\n      } else {\n        result = await (first);\n      }\n    } catch (err) {\n      error = err;\n    }\n    const out = [result, error];\n    out.result = result;\n    out.error = error;\n    return out;\n  });\n\n  bottle.factory('call', () => (fn, ...args) => {\n    if (fn && typeof fn === 'function') {\n      return fn(args);\n    }\n    return null;\n  });\n\n  bottle.factory('explodePromise', ({ NOT_SET, isPromise }) => (promise) => {\n    let done = NOT_SET;\n    let fail = NOT_SET;\n\n    if (isPromise(promise)) {\n      done = (...args) => [...args];\n      fail = (...args) => [...args];\n      promise.then(done).catch(fail);\n    } else promise = new Promise((d, f) => { done = d; fail = f; });\n\n    return Object.assign([promise, done, fail], { done, fail, promise });\n  });\n\n  bottle.factory('update', () => function (delta) {\n    return (actions, ...args) => (state) => {\n      const change = delta(actions, ...args)(state);\n      return Object.assign({}, state, change);\n    };\n  });\n\n  bottle.factory('obj', () => (key, value) => {\n    const out = {};\n    out[key] = value;\n    return out;\n  });\n\n  bottle.constant('NOOP', a => a);\n\n  bottle.factory('isPromise', () => (subject) => {\n    if (!subject) return false;\n    if (subject instanceof Promise) return true;\n    return Promise.resolve(subject) === subject;\n  });\n\n  bottle.factory('functionCombine', ({ call }) => (f1, f2) => async (...args) => {\n    await call(f1, ...args);\n    return call(f2, ...args);\n  });\n\n  bottle.factory('mergeIntoState', () => change => state => Object.assign({}, state, change));\n\n  bottle.factory('timeLimitObservable', () => (observable, delayTime = 1000, errorMessage) => {\n    const killSwitch = from([false, new Error(errorMessage || `took over ${delayTime / 1000} secs`)])\n      .pipe(delay(delayTime));\n\n    return race(observable, killSwitch);\n  });\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/util.js","/* eslint-disable no-unreachable */\n\nimport clone from 'lodash.clonedeep';\n\nimport { BehaviorSubject } from 'rxjs';\n\nexport default (bottle) => {\n  bottle.factory('Store', ({\n    STORE_STATE_UNSET_VALUE,\n    S_NEW,\n    S_STARTING,\n    S_ERROR,\n    S_STOPPED,\n    S_STARTED,\n    NOT_SET,\n    ChangePromise,\n    isPromise,\n  }) => {\n    /**\n     * a Store is a record of a state that updates over time.\n     *\n     * It has a defined status indicating where in the initialization cycle it is:\n     *\n     * NEW > STARTING > STARTED\n     *\n     * note that stores without a starer function begin at STARTED (as start() is a no-op without\n     * a starter function.\n     *\n     * and in some cases in a terminal \"frozen\" state\n     *\n     * > STOPPED | ERROR\n     *\n     * Stores can be stopped, by calling\n     *\n     *   store.stop()\n     *\n     * Stores can also be restarted to back out of a terminal state (> STARTED) by calling\n     *\n     *   store.restart(state?);\n     *\n     * Store updates and actions are designed to handle a \"mixed\n     */\n\n    class Store {\n      constructor(config = {}) {\n        let {\n          state = STORE_STATE_UNSET_VALUE,\n        } = config;\n        const {\n          starter = NOT_SET,\n          debug = false, actions = {},\n        } = config;\n\n        if (state === STORE_STATE_UNSET_VALUE && starter === NOT_SET) state = {};\n\n        this.errorStream = new BehaviorSubject(false);\n\n        try {\n          this.addActions(actions);\n          if (debug) {\n            this.debugStream = new BehaviorSubject({\n              source: 'constructor',\n              config,\n            });\n          }\n          this._state = state;\n          this._starter = starter;\n          this._status = starter !== NOT_SET ? S_NEW : S_STARTED;\n        } catch (err) {\n          this.onError(err);\n        }\n\n        this.stream = new BehaviorSubject({\n          state: this.state,\n          status: this.status,\n        });\n      }\n\n      /* ----------------- PROPERTIES --------------------- */\n\n      get status() {\n        return this._status;\n      }\n\n      get state() {\n        return this._state;\n      }\n\n      /* ----------------- METHODS ------------------------ */\n\n      /**\n       * an action is a function that takes optional arguments\n       * and prepends the store snapshot in front of it. i.e.,\n       *\n       * myStore = new Store({\n       *   state: {a: 4},}\n       *   actions: {\n       *     addA:({state}, a) => ({...state, a: state.a + a})\n       *   }\n       * }\n       *\n       * myStore.actions.addA(3);\n       * // myStore.state.a === 7;\n       *\n       * The signature - what parts of state are pulled into the action signature are arguable.\n       * Freactal, for instance separates the provision of state from the provision of actions.\n       * So an action function can return ....\n       *\n       *  - an object (the next state), OR\n       *  - a function that takes ({actions, state}) and returns .... ^ ^ OR\n       *  - a Promise that returns ^ ^\n       *\n       *  updates keep \"unwrapping\" functions and promises\n       *  til a non-function, non-promise is returned.\n       *  note, if a function returns undefined (i.e., has no return statement), it is a \"No - op\";\n       *  it will not change state _DIRECTLY_\n       *  but it might do so indirectly by calling other actions.\n       */\n\n      /**\n       *\n       * @param actionsMap {Object} a hash of name/function | value parameters.\n       */\n\n      addActions(actionsMap = {}) {\n        const actions = this.actions || {};\n\n        if (actionsMap && typeof actionsMap === 'object') {\n          Object.keys(actionsMap).forEach((name) => {\n            const mutator = actionsMap[name];\n            actions[name] = this.addAction(name, mutator);\n          });\n        } else {\n          this.errorStream.next({\n            source: 'addActions',\n            message: 'bad actionsMap',\n            mutators: actionsMap,\n          });\n        }\n\n        this.actions = actions;\n      }\n\n      /**\n       *\n       * @param name\n       * @param mutator\n       * @returns {function(...[*]): ChangePromise}\n       */\n      addAction(name, mutator) {\n        if (typeof mutator !== 'function') {\n          mutator = () => mutator;\n        }\n        return (...args) => this.update(() => mutator(this, ...args), { action: name || true });\n      }\n\n      /**\n       * takes (or creates) a ChangePromise (which it returns)\n       * and attempts to trigger a state change.\n       *\n       * NOTE: although a promise is returned, change is SYNCHRONOUS unless:\n       *\n       * a) the store is not initialized AND the change doesn't change status,\n       *    in which case it is delayed;\n       * b) the change is itself a promise, in which case change occurs when it is resolved.\n       *\n       * @param change {variant}\n       * @param info {Object} -- metadata; includes potentally a status change.\n       * @returns {ChangePromise}\n       */\n      update(change, info = NOT_SET) {\n        if (!(change instanceof ChangePromise)) {\n          change = new ChangePromise(change, info);\n          this._log({ source: 'update', message: 'created ChangePromise', change });\n        } else {\n          this._log({ source: 'update', message: 'received ChangePromise', change });\n        }\n\n        if (change.status) {\n          return this._resolve(change);\n        }\n\n        switch (this.status) {\n          case NOT_SET:\n            this.after('NotSet', 'status is not set');\n            this._delay(change);\n            break;\n\n          case S_STARTING:\n            if (change.status) {\n              return this._resolve(change);\n            }\n            this._delay(change);\n            break;\n\n          case S_STARTED:\n            return this._resolve(change);\n            break;\n\n          case S_ERROR:\n            this.afterInitError({\n              source: 'update',\n              message: 'change requested of store after init error',\n              change,\n            });\n            setTimeout(() => change.reject(new Error('change requested of errored store')));\n            break;\n\n          case S_STOPPED:\n            this.afterStop({\n              source: 'update',\n              message: 'change requested to stopped store',\n              change,\n            });\n            setTimeout(() => change.reject(new Error('change requested of stopped store')));\n            break;\n\n          default:\n            console.log('unknown status:', this.status);\n            change.reject(new Error(`change cannot resolve - state in unknown status ${this.status.toString()}`));\n        }\n\n        return change;\n      }\n\n      _delay(change) {\n        this._log({\n          source: '_delay',\n          change,\n        });\n        const sub = this.stream.subscribe(() => {\n          switch (this.status) {\n            case S_STARTED:\n              sub.unsubscribe();\n              this.update(change);\n              break;\n\n            case S_ERROR:\n              sub.unsubscribe();\n              change.reject(this.initializationError\n                || new Error('initialization error before change resolved'));\n              break;\n\n            case S_STOPPED:\n              sub.unsubscribe();\n              change.reject(this.initializationError\n                || new Error('store stopped before change resolved'));\n              break;\n\n            default:\n            // noop;\n          }\n        });\n        return change;\n      }\n\n      /**\n       * _resolve should only be hit during/after initialization is complete.\n       * Due to promise delays, we still need to check post-init conditions.\n       *\n       * @param change {ChangePromise}\n       * @returns {ChangePromise} (the input)\n       */\n      _resolve(change) {\n        this._log({ source: '_resolve', change });\n        switch (this.status) {\n          case S_ERROR:\n            // stop\n            change.reject(this.initializationError\n              || new Error('initialization error before change resolved'));\n            return change;\n            break;\n\n          case S_STOPPED:\n            change.reject(this.initializationError\n              || new Error('store stopped before change resolved'));\n            break;\n\n          default:\n          // continue;\n        }\n\n        if (typeof change.value === 'function') {\n          let newState;\n          try {\n            newState = change.value({\n              state: this.state,\n              actions: this.actions,\n            });\n          } catch (error) {\n            this._log({\n              source: '_resolve',\n              message: 'error from change function',\n              error,\n            });\n\n            change.reject(error);\n            // this.onError?\n            this.errorStream.next({ error, change });\n            return change;\n          }\n          this._log({\n            source: '_resolve',\n            message: 'changing state value to function result:',\n            newState,\n            change,\n          });\n          change.value = newState;\n          return this._resolve(change);\n        }\n\n        if (isPromise(change.value)) {\n          change.value\n            .then((unwrapped) => {\n              change.value = unwrapped;\n              this._resolve(change);\n            })\n            .catch((err) => {\n              change.reject(err);\n            });\n          return change;\n        }\n\n        // -- end of the road!\n        if (change.status) {\n          this._log({ source: '_resolve', message: 'updating status', change });\n          this._status = change.status;\n        }\n\n        if (change.value !== NOT_SET && (typeof change.value !== 'undefined')) {\n          this._state = change.value;\n        }\n        this.stream.next({\n          status: this.status,\n          state: this.state,\n        });\n        this._log({ source: '_resolve', message: 'stream updated', change });\n        change.resolve(change.value);\n        this._log({ source: '_resolve', message: 'change resolved', change });\n        return change;\n      }\n\n      afterStart(info) {\n        return this.after('Start', info);\n      }\n\n      afterStop(info) {\n        return this.after('Stop', info);\n      }\n\n      afterInitError(info) {\n        return this.after('InitError', info);\n      }\n\n      after(what, info = 'tried to change') {\n        if (typeof info === 'string') {\n          return this.after(what, new Error(info));\n        }\n        if (!what) what = this._status.toString();\n        this.errorStream.next({ source: `after${what}`, error: info });\n        return info;\n      }\n\n      /**\n       * this method is designed mainly to \"back out\" of an errored state.\n       * @param value\n       */\n\n      restart(value = NOT_SET) {\n        let out;\n        switch (this.status) {\n          // note: for non-error transient states, the value input is ignored..\n          case S_NEW:\n            out = this.start();\n            break;\n\n          case S_STARTING:\n            out = this._startPromise;\n            break;\n\n          case S_STARTED:\n            out = this._startPromise || Promise.resolve(this.state);\n            break;\n\n            /* ----------- THESE ARE THE CONDITIONS THIS METHOD IS MEANT TO ADDRESS ---------- */\n\n          case S_ERROR:\n            out = this.update(value, { status: S_STARTED });\n            break;\n\n          case S_STOPPED:\n            out = this.update(value, { status: S_STARTED });\n            break;\n\n          case NOT_SET:\n            out = this.update(value, { status: S_STARTED });\n            break;\n\n          default:\n            out = this.update(value, { status: S_STARTED });\n        }\n\n        this._startPromise = out;\n        return out;\n      }\n\n      /**\n       * activate whatever starter methods (if any) exist.\n       * note the promise returns the state UPON INTIALIZATION but that value shouldn't be taken\n       * as canon as it might not be up to date.\n       *\n       * @returns {*}\n       */\n      start() {\n        this._log({ source: 'start' });\n\n        if (!this._startPromise) {\n          switch (this.status) {\n            case S_NEW:\n\n              if (!this._starter) {\n                this._log({ source: 'start', message: 'no starter - updating status' });\n                this._startPromise = this.update(NOT_SET, { status: S_STARTED });\n              } else {\n                if (typeof this._starter !== 'function') {\n                  this.onError('bad starter');\n                  return Promise.reject(new Error('bad starter'));\n                }\n                // synchronous status change;\n                this._resolve(new ChangePromise(NOT_SET, { status: S_STARTING }));\n                this._startPromise = this.update(this._starter, { status: S_STARTED });\n              }\n              break;\n\n              /* ------------ MOST OF THESE ARE NEVER GOING TO HAPPEN ----------- */\n\n            case S_STARTING:\n              // REALLY should never happen - startPromise should be set now\n              return Promise.reject(this.afterStart('tried to initialize after starting'));\n              break;\n\n            case S_STARTED:\n              this._startPromise = Promise.resolve(this.state);\n              break;\n\n            case S_ERROR:\n              return Promise.reject(this.afterInitError('tried to initialize after error'));\n              break;\n\n            case S_STOPPED:\n              return Promise.reject(this.afterStop('tried to initialize after stopped'));\n              break;\n\n            default:\n              console.log('strange status: ', this.status);\n              return Promise.reject(new Error(`strange status: ${this.status.toString()}`));\n          }\n        }\n\n        return this._startPromise;\n      }\n\n      /**\n       *\n       * suspends future changes. Optionally accepts one final state change.\n       *\n       * @param value {variant} optional. if present, sets the state to a final value.\n       *\n       * @returns {ChangePromise | Promise}\n       */\n      stop(value) {\n        if (value) {\n          return this.update(value, { status: S_STOPPED });\n        }\n        this._status = S_STOPPED;\n        return Promise.resolve(this.state);\n      }\n\n      onError() {\n        this._status = S_ERROR;\n        this.errorStream.next(new Error('bad starter'));\n      }\n\n      _log(info) {\n        if (this.debugStream) {\n          try {\n            this.debugStream.next({\n              ...info,\n              status: this.status,\n              state: clone(this.state),\n            });\n          } catch (err) {\n            this.debugStream.next({\n              info,\n              status: this.status,\n              state: this.state,\n              _cloneError: err,\n            });\n          }\n        }\n      }\n    }\n\n    return Store;\n  });\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/Store/Store.js","import storeFactory from './Store';\n\nexport default (bottle) => {\n  storeFactory(bottle);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/Store/index.js","\nexport default (bottle) => {\n  bottle.factory('ChangePromise', ({ isPromise, NOT_SET }) => {\n    /**\n     * note a change promise is both a token that gets seeded through the change cycle of stores\n     * and a \"Promise\" -- it has the signature of a promise and behaves like one.\n     *\n     * When it's been fulfilled, calling _resolve will conclude the ChangePromise instance.\n     * On an error, calling reject will abort the ChangePromise instance.\n     */\n\n    let nextId = 0;\n\n    class ChangePromise {\n      constructor(change = NOT_SET, info = {}) {\n        if (typeof change === 'undefined') change = NOT_SET;\n        nextId += 1;\n        this.id = nextId;\n        const executor = (done, fail) => {\n          this._done = done;\n          this._fail = fail;\n        };\n        this._resolved = false;\n\n        this.promise = new Promise(executor);\n        // note - the ORIGINAL change request (function, promise, etc.) is kept as change.\n        // at it is unravelled the current value is kept in value;\n\n        this.change = change;\n        this.value = change;\n\n        this.info = info === NOT_SET ? {} : info;\n      }\n\n      get resolved() {\n        return this._resolved;\n      }\n\n      get status() {\n        if (!this.info) return NOT_SET;\n\n        return this.info.status || NOT_SET;\n      }\n\n      /**\n       * _resolve (optionally) sets the final value of the change\n       * and closes the promise. It can only execute once.\n       *\n       * If value is (or is set to) a value then the change\n       * resolves that value and takes the result as the change's value\n       * then returns it.\n       *\n       * @param value {variant} optional\n       * @returns {Promise}\n       */\n      resolve(value = NOT_SET) {\n        if (this.resolved) {\n          return this.promise;\n        }\n        if (value !== NOT_SET) {\n          this.value = value;\n        }\n\n        if (isPromise(this.value)) {\n          return this.value.then(unravelled => this.resolve(unravelled));\n        }\n\n        this._resolved = true;\n        this._done(this.value);\n        return this.promise;\n      }\n\n      reject(value = NOT_SET) {\n        if (this.resolved) {\n          console.log('ChangePromise reject called with ', value, 'after _resolve');\n          return this.promise;\n        }\n\n        this._resolved = true;\n        if (value !== NOT_SET) this.error = value;\n        try {\n          this._fail(this.error);\n        } catch (err) {\n          console.log('error:', err);\n        }\n        return this.promise;\n      }\n\n      then(...args) {\n        return this.promise.then(...args);\n      }\n\n      catch(listener) {\n        return this.promise.catch(listener);\n      }\n    }\n\n    return ChangePromise;\n  });\n\n  bottle.factory('change', ({ ChangePromise }) => (newValue, params = {}) => new ChangePromise(newValue, params));\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/ChangePromise/ChangePromise.js","import changePromiseFactory from './ChangePromise';\n\nexport default (bottle) => {\n  changePromiseFactory(bottle);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/ChangePromise/index.js","import bottle from './bottle';\n\n\nconst {\n  Store, Engine, EngineMerger, update, mergeIntoState,\n  STORE_STATE_UNSET_VALUE\n  , S_NEW\n  , S_STARTED\n  , S_STARTING\n  , S_ERROR\n  , ACTION_ERROR\n  , ACTION_START\n  , ACTION_NOOP\n  , ACTION_COMPLETE\n  , NOT_SET,\n} = bottle().container;\n\nconsole.log('Engine:', Engine);\nexport {\n  STORE_STATE_UNSET_VALUE\n  , S_NEW\n  , S_STARTED\n  , S_STARTING\n  , S_ERROR\n  , ACTION_ERROR\n  , ACTION_START\n  , ACTION_NOOP\n  , ACTION_COMPLETE\n  , NOT_SET,\n  Store,\n  Engine,\n  EngineMerger,\n  update,\n  mergeIntoState,\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import Bottle from 'bottlejs';\nimport constants from './constants';\nimport util from './util';\nimport storeFactory from './Store';\nimport changePromiseFactory from './ChangePromise';\n\nexport default () => {\n  const bottle = new Bottle();\n  [constants, changePromiseFactory, util, storeFactory].forEach(factory => factory(bottle));\n  return bottle;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/bottle.js","module.exports = require(\"bottlejs\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"bottlejs\"\n// module id = 3\n// module chunks = 0"],"sourceRoot":""}